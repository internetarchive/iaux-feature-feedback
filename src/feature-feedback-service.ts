import type { Result } from '@internetarchive/result-type';
import { SurveyQuestionResponse, Vote } from './models';

export interface FeatureFeedbackServiceInterface {
  submitFeedback(options: {
    featureIdentifier: string;
    vote: Vote;
    comments?: string;
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>>;

  /**
   * Submits a set of survey responses to the configured service URL.
   * @param options Details about the survey:
   *  - `surveyIdentifier`: Internal identifier of the survey
   *  - `responses`: List of responses to the survey questions
   *  - `recaptchaToken`: Token generated by the ReCAPTCHA service
   */
  submitSurvey(options: {
    surveyIdentifier: string;
    responses: SurveyQuestionResponse[];
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>>;
}

export class FeatureFeedbackService implements FeatureFeedbackServiceInterface {
  private serviceUrl: string;

  constructor(options: { serviceUrl: string }) {
    this.serviceUrl = options.serviceUrl;
  }

  async submitFeedback(options: {
    featureIdentifier: string;
    vote: Vote;
    comments?: string | undefined;
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>> {
    const url = new URL(this.serviceUrl);
    url.searchParams.append('featureId', options.featureIdentifier);
    url.searchParams.append('rating', options.vote);
    if (options.comments) {
      url.searchParams.append('comment', options.comments);
    }
    url.searchParams.append('token', options.recaptchaToken);
    try {
      const response = await fetch(url.href);
      const json = await response.json();
      return json as Result<boolean, Error>;
    } catch (error) {
      let err: Error;
      if (error instanceof Error) {
        err = error;
      } else if (typeof error === 'string') {
        err = new Error(error);
      } else {
        err = new Error('Unknown error');
      }

      return {
        success: false,
        error: err,
      };
    }
  }

  /**
   * @inheritdoc
   */
  async submitSurvey(options: {
    surveyIdentifier: string;
    responses: SurveyQuestionResponse[];
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>> {
    const url = new URL(this.serviceUrl);
    url.searchParams.append('surveyId', options.surveyIdentifier);
    url.searchParams.append('token', options.recaptchaToken);
    const body = JSON.stringify({
      surveyResponses: options.responses
        .map(resp => {
          const sentResponse: Record<string, string> = {
            question: resp.question.questionText,
          };
          if (resp.vote) sentResponse.vote = resp.vote;
          if (resp.comment) sentResponse.comment = resp.comment;
          return sentResponse;
        })
        .filter(resp => !!resp.question),
    });

    try {
      const response = await fetch(url.href, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body,
      });
      const json = await response.json();
      return json as Result<boolean, Error>;
    } catch (error) {
      let err: Error;
      if (error instanceof Error) {
        err = error;
      } else if (typeof error === 'string') {
        err = new Error(error);
      } else {
        err = new Error('Unknown error');
      }

      return {
        success: false,
        error: err,
      };
    }
  }
}

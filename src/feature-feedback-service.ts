import type { Result } from '@internetarchive/result-type';
import { SurveyQuestionResponse, Vote } from './models';

export interface FeatureFeedbackServiceInterface {
  /**
   * Submits a feedback entry to the configured service URL.
   * @param options Details about the survey:
   *  - `featureIdentifier`: Internal identifier for the feature being rated
   *  - `vote`: The up/down rating for the feature
   *  - `comments`: (Optional) A text comment about the feature
   *  - `recaptchaToken`: Token generated by the ReCAPTCHA service
   */
  submitFeedback(options: {
    featureIdentifier: string;
    vote: Vote;
    comments?: string;
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>>;

  /**
   * Submits a set of survey responses to the configured service URL.
   * @param options Details about the survey:
   *  - `surveyIdentifier`: Internal identifier of the survey to be submitted
   *  - `responses`: List of responses to the survey questions
   *  - `recaptchaToken`: Token generated by the ReCAPTCHA service
   */
  submitSurvey(options: {
    surveyIdentifier: string;
    responses: SurveyQuestionResponse[];
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>>;
}

export class FeatureFeedbackService implements FeatureFeedbackServiceInterface {
  private serviceUrl: string;

  constructor(options: { serviceUrl: string }) {
    this.serviceUrl = options.serviceUrl;
  }

  /**
   * @inheritdoc
   */
  async submitFeedback(options: {
    featureIdentifier: string;
    vote: Vote;
    comments?: string | undefined;
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>> {
    const url = new URL(this.serviceUrl);
    url.searchParams.append('featureId', options.featureIdentifier);
    url.searchParams.append('rating', options.vote);
    if (options.comments) {
      url.searchParams.append('comment', options.comments);
    }
    url.searchParams.append('token', options.recaptchaToken);
    try {
      const response = await fetch(url.href);
      const json = await response.json();
      return json as Result<boolean, Error>;
    } catch (error) {
      let err: Error;
      if (error instanceof Error) {
        err = error;
      } else if (typeof error === 'string') {
        err = new Error(error);
      } else {
        err = new Error('Unknown error');
      }

      return {
        success: false,
        error: err,
      };
    }
  }

  /**
   * @inheritdoc
   */
  async submitSurvey(options: {
    surveyIdentifier: string;
    responses: SurveyQuestionResponse[];
    recaptchaToken: string;
  }): Promise<Result<boolean, Error>> {
    const url = new URL(this.serviceUrl);
    url.searchParams.append('surveyId', options.surveyIdentifier);
    url.searchParams.append('token', options.recaptchaToken);
    const body = JSON.stringify({
      surveyResponses: options.responses.map(resp => ({
        question: resp.question.questionText,
        ...(resp.vote ? { rating: resp.vote } : {}),
        ...(resp.comment ? { comment: resp.comment } : {}),
      })),
    });

    try {
      const response = await fetch(url.href, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body,
      });
      const json = await response.json();
      return json as Result<boolean, Error>;
    } catch (error) {
      let err: Error;
      if (error instanceof Error) {
        err = error;
      } else if (typeof error === 'string') {
        err = new Error(error);
      } else {
        err = new Error('Unknown error');
      }

      return {
        success: false,
        error: err,
      };
    }
  }
}
